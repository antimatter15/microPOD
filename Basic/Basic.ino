#include <mbedtls/bignum.h>
#include <esp_bignum.h>
#include "mbedtls/base64.h"
#include <pod_util.h>
#include <blake.h>
#include <ArduinoJson.h>
#include <Preferences.h>

Preferences preferences;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);


  preferences.begin("crypto", false);
  
  delay(100);

  unsigned int start_init_time = millis();
  init_babyjub_constants();
  Serial.print("Init constants time: ");
  Serial.println(millis() - start_init_time);
}

void loop() {
  // put your main code here, to run repeatedly:
  Serial.println("hello");

  ecdsa_test();
  
  delay(5000);
}



void ecdsa_test() {
  StaticJsonDocument<256> doc;
  unsigned int beginTime = millis();

  int number = preferences.getInt("number", 1);


  doc["counter"]["type"] = "int";
  doc["counter"]["value"] = number;

  doc["zupass_description"]["type"] = "string";
  doc["zupass_description"]["value"] = "#" + String(number) + " Generated by ESP32-C3";

  doc["zupass_display"]["type"] = "string";
  doc["zupass_display"]["value"] = "collectable";
//
//  doc["zupass_image_url"]["type"] = "string";
//  doc["zupass_image_url"]["value"] = "https://i.imgur.com/ZbGZyPH.jpeg";

  doc["zupass_title"]["type"] = "string";
  doc["zupass_title"]["value"] = "ESP32 POD #" + String(number);

  

  int count = doc.size() * 2;
  mbedtls_mpi *items = (mbedtls_mpi*)malloc(sizeof(mbedtls_mpi) * count);
  int index = 0;
  for (JsonPair kv : doc.as<JsonObject>()) {
    const char* key = kv.key().c_str();
    Serial.println(key);
  
    JsonObject value = kv.value().as<JsonObject>();
    mbedtls_mpi_init(&items[index]);
    mbedtls_mpi_init(&items[index + 1]);
    sha256_hash_mpi(&items[index], key, strlen(key));

    if (strcmp(value["type"], "int") == 0) {
      mbedtls_mpi input;
      mbedtls_mpi_init(&input);
      mbedtls_mpi_lset(&input, value["value"].as<int>());
      poseidon(&items[index + 1], &input, 1);
      mbedtls_mpi_free(&input);
    } else if (strcmp(value["type"], "string") == 0) {
      const char* str_value = value["value"];
      sha256_hash_mpi(&items[index + 1], str_value, strlen(str_value));
    }
    index += 2;
  }

  Serial.print("Computing Merkle Tree... ");
  while (count > 1) {
    for (int i = 0; i < count; i += 2) {
      Serial.print(i);
      if (i + 1 < count) {
        poseidon(&items[i / 2], &items[i], 2);
      } else {
        mbedtls_mpi_copy(&items[i / 2], &items[i]);
      }
    }
    count = (count + 1) / 2;
  }

  Serial.print(" Time (ms): ");
  Serial.println(millis() - beginTime);

  char result_str[200];
  size_t olen;
  mbedtls_mpi_write_string(&items[0], 10, result_str, sizeof(result_str), &olen);
  Serial.print("Poseidon2 Merkle Root: ");
  Serial.println(result_str);

  mbedtls_mpi message;
  mbedtls_mpi_init(&message);
  mbedtls_mpi_copy(&message, &items[0]);
  for (int i = 0; i < doc.size() * 2; i++) mbedtls_mpi_free(&items[i]);
  free(items);

  uint8_t privateKey[32];
  if (preferences.getBytes("privateKey", privateKey, 32) != 32) {
    Serial.println("Generating Private Key");
    esp_fill_random(privateKey, 32);
    preferences.putBytes("privateKey", privateKey, 32);
  }

  char x_str[200], y_str[200];

  uint8_t sBuff[64];
  blake512_hash(sBuff, privateKey, 32);

  // pruneBuffer
  sBuff[0] = sBuff[0] & 0xF8;
  sBuff[31] = sBuff[31] & 0x7F;
  sBuff[31] = sBuff[31] | 0x40;

  mbedtls_mpi s;
  mbedtls_mpi_init(&s);
  reverse_endianness(sBuff, 32);
  mbedtls_mpi_read_binary(&s, sBuff, 32);

  // Serial.println("Private Key (s):");
  // mbedtls_mpi_write_string(&s, 10, y_str, sizeof(y_str), &olen);
  // Serial.println(y_str);

  // Process second half of sBuff and message
  uint8_t rBuff[64];
  memset(rBuff, 0, 64);
  memcpy(rBuff, sBuff + 32, 32);
  mbedtls_mpi_write_binary(&message, rBuff + 32, 32);
  reverse_endianness(rBuff + 32, 32); // Ensure little-endian
  blake512_hash(rBuff, rBuff, 64);

  // Calculate r = rBuff % SubOrder
  mbedtls_mpi r;
  mbedtls_mpi_init(&r);
  reverse_endianness(rBuff, 64); // Ensure little-endian
  mbedtls_mpi_read_binary(&r, rBuff, 64);
  mbedtls_mpi_mod_mpi(&r, &r, &SubOrder);

  // Serial.println("r:");
  // mbedtls_mpi_write_string(&r, 10, y_str, sizeof(y_str), &olen);
  // Serial.println(y_str);

  // ss = s >> 3
  mbedtls_mpi ss;
  mbedtls_mpi_init(&ss);
  mbedtls_mpi_copy(&ss, &s);
  mbedtls_mpi_shift_r(&ss, 3);


  // calculate A (public key) = Base8 * ss
  Point A;
  mbedtls_mpi_init(&A.x); mbedtls_mpi_init(&A.y);

  String pkX = preferences.getString("publicKey.x", "");
  String pkY = preferences.getString("publicKey.y", "");

  if (pkX.isEmpty() || pkY.isEmpty()) {
    Serial.println("Deriving Public Key... ");
    unsigned int startTime = millis();
    multiply_bj(&A, &Base8, &ss);
    mbedtls_mpi_write_string(&A.x, 10, x_str, sizeof(x_str), &olen);
    mbedtls_mpi_write_string(&A.y, 10, y_str, sizeof(y_str), &olen);
    Serial.println(x_str);
    Serial.println(y_str);

    preferences.putString("publicKey.x", x_str);
    preferences.putString("publicKey.y", y_str);

    Serial.print("Time: ");
    Serial.println(millis() - startTime);
  } else {
    mbedtls_mpi_read_string(&A.x, 10, pkX.c_str());
    mbedtls_mpi_read_string(&A.y, 10, pkY.c_str());
  }

  uint8_t pubKey[32];
  mbedtls_mpi_write_binary(&A.y, pubKey, 32);
  reverse_endianness(pubKey, 32); // Ensure little-endian
  if (mbedtls_mpi_cmp_mpi(&A.x, &pm1d2) > 0) pubKey[31] |= 0x80;


  size_t base64_len;
  unsigned char base64_pubkey[45];  // ceil(32 * 4/3) + 1 for null terminator
  mbedtls_base64_encode(base64_pubkey, sizeof(base64_pubkey), &base64_len, pubKey, 32);
  base64_pubkey[base64_len] = '\0';
  Serial.print("Base64 Public Key: ");
  Serial.println((char*)base64_pubkey);

  // Calculate R8
  Point R8;
  mbedtls_mpi_init(&R8.x); mbedtls_mpi_init(&R8.y);
  Serial.print("Computing Signature (R8)... ");
  unsigned int startTime = millis();
  multiply_bj(&R8, &Base8, &r);

  mbedtls_mpi_write_string(&R8.x, 10, x_str, sizeof(x_str), &olen);
  mbedtls_mpi_write_string(&R8.y, 10, y_str, sizeof(y_str), &olen);
  Serial.print(x_str);
  Serial.print(", ");
  Serial.println(y_str);

  Serial.print("Time: ");
  Serial.println(millis() - startTime);


  mbedtls_mpi inputs[5];
  inputs[0] = R8.x;
  inputs[1] = R8.y;
  inputs[2] = A.x;
  inputs[3] = A.y;
  inputs[4] = message;

  mbedtls_mpi hms;
  mbedtls_mpi_init(&hms);
  Serial.print("Computing Poseidon5 Hash... ");
  startTime = millis();
  poseidon(&hms, inputs, 5);

  mbedtls_mpi_write_string(&hms, 10, x_str, sizeof(x_str), &olen);
  Serial.println(x_str);

  Serial.print("Time: ");
  Serial.println(millis() - startTime);


  // S = (r + hms*s) % SubOrder
  mbedtls_mpi S;
  mbedtls_mpi_init(&S);
  mbedtls_mpi_mul_mpi(&S, &hms, &s);
  mbedtls_mpi_add_mpi(&S, &r, &S);
  mbedtls_mpi_mod_mpi(&S, &S, &SubOrder);

  //  Serial.println("S:");
  //  mbedtls_mpi_write_string(&S, 10, x_str, sizeof(x_str), &olen);
  //  Serial.println(x_str);

  uint8_t signature[64];
  memset(signature, 0, 64);

  mbedtls_mpi_write_binary(&R8.y, signature, 32);
  reverse_endianness(signature, 32); // Ensure little-endian
  if (mbedtls_mpi_cmp_mpi(&R8.x, &pm1d2) > 0) signature[31] |= 0x80;


  mbedtls_mpi_write_binary(&S, signature + 32, 32);
  reverse_endianness(signature + 32, 32); // Ensure little-endian


  base64_len = 0;
  unsigned char base64_signature[90];  // ceil(32 * 4/3) + 1 for null terminator
  mbedtls_base64_encode(base64_signature, sizeof(base64_signature), &base64_len, signature, 64);
  base64_signature[base64_len] = '\0';
  Serial.print("Base64 EdDSA Signature: ");
  Serial.println((char*)base64_signature);

  preferences.putInt("number", number + 1);

  StaticJsonDocument<1024> pcd;
  String uuid = generateUUID();
  pcd["id"] = uuid;

  JsonObject claim = pcd.createNestedObject("claim");
  claim["entries"] = doc;
  claim["signerPublicKey"] = base64_pubkey;

  JsonObject proof = pcd.createNestedObject("proof");
  proof["signature"] = base64_signature;

  // Pretty print JSON directly to Serial
  //  serializeJsonPretty(pcd, Serial);
  //  Serial.println();

  String jsonPCDString;
  serializeJson(pcd, jsonPCDString);

  StaticJsonDocument<1024> addLink;
  
  addLink["type"] = "Add";
  addLink["redirectToFolder"] = "true";
  addLink["folder"] = "0xPARC Summer '24/0xPODs";
  addLink["returnUrl"] = "https://zupass.org/";
  
  JsonObject addLinkPCD = addLink.createNestedObject("pcd");
  addLinkPCD["type"] = "pod-pcd";
  addLinkPCD["pcd"] = jsonPCDString;

  Serial.print("Total Elapsed Time (ms): ");
  Serial.println(millis() - beginTime);

  String addLinkJsonString;
  serializeJson(addLink, addLinkJsonString);
  String zupassURL = "https://zupass.org/#/add?request=" + urlEncode(addLinkJsonString);

  Serial.println();
  Serial.println(zupassURL);



  // Cleanup
  mbedtls_mpi_free(&A.x); mbedtls_mpi_free(&A.y);
  mbedtls_mpi_free(&R8.x); mbedtls_mpi_free(&R8.y);

  mbedtls_mpi_free(&hms);
  mbedtls_mpi_free(&ss);
  mbedtls_mpi_free(&s);
  mbedtls_mpi_free(&S);
  mbedtls_mpi_free(&r);
}
